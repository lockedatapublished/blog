---
title: "Speed Up With Microsoft"
date: 2018-09-21T11:19:59+01:00
draft: true
author: "Dave"
---
People use R for lots of reasons: "It's great for the models I need", "I like the functional approach", "It's the tool I'm most comfortable with". 

People don't use R for these reasons: "I love how my memory needs to fit all my data", "I have a favourite processor core, I don't want to use the others".

What if I told you that you didn't need to worry about that any more?

<div style="width:100%;height:0;padding-bottom:42%;position:relative;"><iframe src="https://giphy.com/embed/NaAIXJ9pb0q5i" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/deadpool-movie-2015-NaAIXJ9pb0q5i">via GIPHY</a></p>

Microsoft have their own version of `R` called [Microsoft R Client](https://docs.microsoft.com/en-us/machine-learning-server/r-client/what-is-microsoft-r-client). It has a bunch of high-tech, whizz-bang features, but we're going to focus on one: multi-threading calculations. Vanilla `R` is single threaded.This means any calculations are done sequentially, in order, one at a time. However, this isn't using the ability of most modern, domestic laptops. To get setup with Microsoft R Client, [follow the install instructions](https://docs.microsoft.com/en-us/machine-learning-server/r-client/install-on-windows). 
Once you've got Microsoft R Client installed, you will need to make sure it's the version of `R` that is active in your session. If you are using RStudio this is easy to do by going to `Tools > Global Options > General > R Version`. 

![](../img/R-options-rclient.PNG)

You will probably be asked to Restart R Studio, so close it and open back up, then we can run the code.


```
R version 3.4.3 (2017-11-30) -- "Kite-Eating Tree"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

Microsoft R Open 3.4.3
The enhanced R distribution from Microsoft
Microsoft packages Copyright (C) 2018 Microsoft

Loading Microsoft R Client packages, version 3.4.3.0097. 
Microsoft R Client limits some functions to available memory.
See: https://go.microsoft.com/fwlink/?linkid=799476 for information
about additional features.

Type 'readme()' for release notes, privacy() for privacy policy, or
'RevoLicense()' for licensing information.

Using the Intel MKL for parallel mathematical computing(using 2 cores).
Default CRAN mirror snapshot taken on 2018-01-01.
See: https://mran.microsoft.com/.
```

This message will pop up, and it's worth noting as it's got some information in it that you might need to think about:

* It's worth noting that right now Microsoft r Client is lagging behind the curent `R` version, and is based on version 3.4 of `R`, not 3.5. This will mean your default package libraries will not be shared between the installations if you are running `R` 3.5.
* It's using a snapshot of `CRAN` called `MRAN` to source packages by default. 90% of the time it will operate just as you expect, but because it takes a 'snapshot' of packages, newer features and changes that have hit `CRAN` may not be in the version of the package you are grabbing.
    + `RevoScaleR` and probably the `ggplot2` and `dplyr` packages will likely be installed for you already as default in Microsoft R Client. The other two you will probably have to install yourself.
* Intel MKL will have scanned your system on install and attempted to work out how many cores your processor has. Here it's identified 2 on my old Lenovo Yoga. This is where the speed boost will come from.

```{r setup}
knitr::opts_chunk$set(echo = TRUE)
library(microbenchmark)
library(RevoScaleR)
library(ggplot2)
library(lockeutils)
theme_set(theme_ld() + theme(axis.title.x = element_text(vjust = -1)))
library(dplyr)
```

## Faster

Here we make a set of example data, 3 data frame of random numbers with various 'normal' distributions. the data frames are of different lengths: 500,000 , 1,000,000 and 5,000,000.

```{r create example data}
set.seed(9000)
sample_df = function(n){
  data.frame(
    col_1 = c(rnorm(n, mean = 11, sd = 0.5)), 
    col_2 = c(rnorm(n, mean = 6, sd = 1)), 
    col_3 = c(rnorm(n, mean = 3, sd = 0.75))
  )
}

df_500k <- sample_df(500000)
df_1m <- sample_df(1000000)
df_5m <- sample_df(5000000)
```

Running benchmarks in `R` is easy with the microbenchmark package. The package tries to be as accurate as possible in measuring the time for each of it's runs, and also allows you to easily compare different approaches and specify the amount of repeats. I've decided to test each of the 3 data sets in each of 2 different linear modelling functions, giving 6 different groups of results. Each group will be run 10 times for a total set of 60 runs. 

```{r run benchmarking}
res <- microbenchmark(
  lm_50k = lm(col_1 ~ col_2 + col_3, data = df_500k),
  rxLM_50k = rxLinMod(col_1 ~ col_2 + col_3, data = df_500k),
  lm_1m = lm(col_1 ~ col_2 + col_3, data = df_1m),
  rxLM_1m = rxLinMod(col_1 ~ col_2 + col_3, data = df_1m),
  lm_5m = lm(col_1 ~ col_2 + col_3, data = df_5m),
  rxLM_5m = rxLinMod(col_1 ~ col_2 + col_3, data = df_5m),
  times = 10
  )
```

The `res` object is of class `microbenchmark`, and has a plotting method that can be used via `ggplot2::autoplot()`.

```{r generate results plot}
autoplot(res) +  
  labs(title = "Violin plot of model run durations", 
       subtitle = "`rxLinMod()` vs `lm()`",
       caption = "Microsoft R Client 3.4.3, 2 cores")
```

In each of these tests, we can see that the `RevoScaleR::rxLinMod()` functions outperforms the base `lm()` by a large margin. Note the log scale for `Time [milliseconds]`!

```{r generate results table}
summary(res)
```

## Bigger

So now you can easily use the full power of your memory for calculating models faster, but what if your data doesn't fit into your local memory at all?

<div style="width:100%;height:0;padding-bottom:75%;position:relative;"><iframe src="https://giphy.com/embed/MvedbKot538WY" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/MvedbKot538WY">via GIPHY</a></p>

Remember, memory is your RAM, the bit that does the calcs, and is usually in the reaml of 4-16 GB on most laptops. So you can only compute on objects that are smaller than that, baring in mind that every 'active' process is also eating into that threshold, the operating systems, background processes and active applications. Your disk space, a HDD or SDD is magnitudes larger, 100s of GB to multiple TB. We can use this to overcome our size issue.

### Minimum Examle

Lets get some example data. Here I'm downloading a `.zip` to a temp folder, unzipping it, reading it (into memory admitedly, this is just an example!) and then writing it out to a csv in the working directory. In practice this could be done via bash/shell or interactively without hitting `R` memory at all.

```{r download and extract data}
temp <- tempfile()
download.file("https://packages.revolutionanalytics.com/datasets/mortDefault.zip", temp)
write.csv(read.csv(unz(temp, "mortDefault2000.csv")), "./mortDefault2000.csv")
```

```{r write xdf}
mySourceData <- file.path(getwd(), "mortDefault2000.csv")
myNewXDF <- file.path(paste0(getwd(),"/mortDefaultSmall2000.xdf"))
rxImport(inData = mySourceData, outFile = myNewXDF)
mortDefault2000Info <- rxGetInfo(myNewXDF, getVarInfo = TRUE)
mortDefault2000Info
```

I've specified two file paths in `mySourceData` and `mynewXDF`. Just length 1 character strings, no fancy classes or data here.

`rxImport()` takes these strings as a data source and a data destination and writes a version of the old `.csv` to a new file type, an `.xdf`. `rxGetInfo()` retrieves _metadata_ from the file, not the data itself. It's less than 10 KB in size.

```{r getInfo size}
object.size(mortDefault2000Info)
```



```
unlink(temp)
```

https://docs.microsoft.com/en-us/machine-learning-server/r/concept-what-is-xdf



